From b1bc57688be84777c4c94180ece3646f802c73f2 Mon Sep 17 00:00:00 2001
From: sunjunchao <sunjunchao2870@gmail.com>
Date: Mon, 26 Jun 2023 17:18:04 +0800
Subject: [PATCH] add lab1 solution

---
 Makefile        |  4 +++
 user/find.c     | 94 +++++++++++++++++++++++++++++++++++++++++++++++++
 user/pingpong.c | 39 ++++++++++++++++++++
 user/sleep.c    | 15 ++++++++
 user/xargs.c    | 63 +++++++++++++++++++++++++++++++++
 5 files changed, 215 insertions(+)
 create mode 100644 user/find.c
 create mode 100644 user/pingpong.c
 create mode 100644 user/sleep.c
 create mode 100644 user/xargs.c

diff --git a/Makefile b/Makefile
index ded5bc2..c98e179 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,10 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_find\
+	$U/_xargs\
 
 
 
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..55597af
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,94 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+#define NULL ((void*)0)
+
+void strcat(char *str, const char *fix) {
+    int i = 0;
+    int j = strlen(str);
+
+    for (i = 0; fix[i]; ++i, ++j) {
+        str[j] = fix[i];
+    }
+
+    str[j] = '\0';
+
+}
+
+#define LEN 100   // can not be too large, otherwise page fault
+
+void find(char *dir, char *name) {
+    struct dirent de;
+    struct stat st;
+    int fd;
+    char cur_dir[LEN] = {0};
+
+    if ((fd = open(dir, 0)) < 0){
+        fprintf(2, "find: cannot open %s\n", dir);
+        return;
+    }
+
+    if (fstat(fd, &st) < 0){
+        fprintf(2, "find: cannot stat %s\n", dir);
+        close(fd);
+        return;
+    }
+    
+    memcpy(cur_dir, dir, strlen(dir));
+    strcat(cur_dir, "/");
+    if (st.type == T_DIR) {
+        int ret;
+        if(strlen(dir) + 1 + DIRSIZ + 1 > sizeof cur_dir){
+            printf("find: path too long\n");
+            return;
+        }
+        char path[LEN] = {0};
+        while ((ret = read(fd, &de, sizeof(de))) == sizeof(de)) {
+            if (!strlen(de.name)) {
+                continue;
+            }
+            strcpy(path, cur_dir);
+            strcat(path, de.name);
+            if (stat(path, &st) < 0) {
+                printf("find: cannot stat %s\n", path);
+                continue;
+            }
+            if (de.inum == 0 || strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0) {
+                continue;
+            }
+            if (strcmp(de.name, name) == 0) {
+                printf("%s\n", path);
+            }
+
+            if (st.type == T_DIR) {
+                char next_dir[LEN] = {0};
+
+                strcpy(next_dir, cur_dir);
+                strcat(next_dir, de.name);
+                find(next_dir, name);
+            }
+        }
+
+    } else {
+        exit(1);
+    }
+}
+
+int main(int argc, char **argv) {
+	char *dir = NULL;
+	char *name = NULL;
+	
+	if (argc != 3) {
+		printf("USAGE: %s $dir $name", argv[0]);
+        exit(1);
+	}
+	
+    dir = argv[1];
+    name = argv[2];
+
+    find(dir,name);
+
+    exit(0);
+}
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..ee38e52
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,39 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main (int argc, char **argv) {
+	int fd0[2];
+	int fd1[2];
+
+	if (pipe(fd0) < 0) {
+		exit(1);
+	}
+	if (pipe(fd1) < 0) {
+		exit(1);
+	}
+
+	if (fork() == 0) {
+		// child process
+		int a;
+		close(fd0[0]);
+		close(fd1[1]);
+
+		read(fd1[0], &a, 1);
+		printf("%l: received ping\n", getpid());
+		write(fd0[1], "b", 1);
+		exit(0);
+	} else {
+		// parent process
+		int a;
+		close(fd0[1]);
+		close(fd1[0]);
+
+		write(fd1[1], "a", 1);
+		read(fd0[0], &a, 1);
+		printf("%l: received pong\n", getpid());
+		exit(0);
+	}
+	
+	
+}
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..4c62243
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,15 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char **argv)
+{
+	if (argc != 2) {
+		printf("USAGE: %s $sec\n", argv[0]);
+		exit(1);
+	}
+	int sleep_s = atoi(argv[1]);
+	sleep(sleep_s);
+
+	exit(0);
+}
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..a8a8f56
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,63 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/param.h"
+
+#define MAX_INPUT_LEN 100
+
+int main (int argc, char **argv) {
+    int i = 0;
+    int rc;
+    char *buf = (void*)0;
+    char **new_argv= (void*)0;
+
+    if (argc > MAXARG) {
+        fprintf(2, "too much argv\n");
+        exit(1);
+    }
+    
+    new_argv = malloc(sizeof(void*)*10);
+    buf = malloc(MAX_INPUT_LEN);
+    
+    if (!buf || !new_argv) {
+        fprintf(2, "xargs: malloc failed\n");
+        exit(1);
+    }
+    
+    // append stdin to argv
+    for (i = 0; i < argc; ++i) {
+        new_argv[i] = argv[i];
+    }
+    i = 0;
+    while (1) {
+        if (i >= MAX_INPUT_LEN) {
+            fprintf(2, "xargs: too long input\n");
+            exit(1);
+        }
+        rc = read(0, buf+i, 1);
+
+        i++;
+        if (buf[i-1] == ' ' || buf[i-1] == '\n') {
+            buf[i-1] = '\0';
+            new_argv[argc]= buf;
+            buf += (i);
+            i = 0;
+            argc++;
+        }
+        if (rc <= 0) {
+            break;
+        }
+    }
+    new_argv[argc] = (void*)0;
+
+    if (fork() == 0) {
+        // child process
+        exec(new_argv[1], new_argv+1);
+    } else {
+        // parent process
+        wait(0);
+    }
+
+    exit(0);
+}
-- 
2.25.1

